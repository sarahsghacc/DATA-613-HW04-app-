mean = 23.54,
std_dev = 2.442
)
z_score <- (data - data$mean) / data$std_dev
z_score(25.77, 23.54, 2.442)
library(tidyverse)
library(purrr)
data <- data.frame(
obs_value = 25.77,
mean = 23.54,
std_dev = 2.442
)
z_score <- (data - data$mean) / data$std_dev
z_score
library(tidyverse)
library(purrr)
data <- data.frame(
obs_value = 25.77,
mean = 23.54,
std_dev = 2.442
)
z_score <- (data$obs_value - data$mean) / data$std_dev
z_score
library(tidyverse)
data <- data.frame(
obs_value = 25.77,
mean = 23.54,
std_dev = 2.442
)
z_score <- (data$obs_value - data$mean) / data$std_dev
z_score
library(tidyverse)
z_score <- function(obs_value, mean, std_dev) {
(obs_value - mean) / std_dev
}
data <- data.frame(
obs_value = 25.77,
mean = 23.54,
std_dev = 2.442
)
z_score <- (data)
z_score
library(tidyverse)
z_score <- function(obs_value, mean, std_dev) {
(obs_value - mean) / std_dev
}
data <- data.frame(
obs_value = 25.77,
mean = 23.54,
std_dev = 2.442
)
z_score(25.77, 23.54,2.442)
ln_formula <- function(x, p){
(log(x) * log10(x)) / (p^(1/3))
}
ln_formula(32, 11)
# Initialize output
std_dev_results <- numeric(length = ncol(mtcars))
# Loop through columns
for (i in seq_along(mtcars)) {
sd_results[i] <- sd(mtcars[[i]])
}
# Assign names
names(std_dev_results) <- names(mtcars)
std_dev_results
# Initialize output
sd_results <- numeric(length = ncol(mtcars))
# Loop through columns
for (i in seq_along(mtcars)) {
sd_results[i] <- sd(mtcars[[i]])
}
# Assign names
names(sd_results) <- names(mtcars)
sd_results
?mtcars
# Initialize output
sd_results <- numeric(length = ncol(mtcars))
# Loop through columns
for (i in seq_along(mtcars)) {
sd_results[i] <- sd(mtcars[[i]])
}
# Assign names
names(sd_results) <- as.tibble(names(mtcars))
sd_results
# Initialize output
sd_results <- as.tibble(numeric(length = ncol(mtcars)))
# Loop through columns
for (i in seq_along(mtcars)) {
sd_results[i] <- sd(mtcars[[i]])
}
# Assign names
names(sd_results) <- names(mtcars)
sd_results
View(sd_results)
# Initialize output
sd_results <- sd(mtcars)
# Loop through columns
for (i in seq_along(mtcars)) {
sd_results[i] <- sd(mtcars[[i]])
}
# Assign names
names(sd_results) <- names(mtcars)
sd_results
# Initialize output
sd_results <- sd(mtcars)
sd_results
View(sd_results)
sd_vec <- vector(mode = "numeric", length = length(mtcars))
for (i in seq_along(mtcars)) {
sd_vec[[i]] <- sd(mtcars[[i]], na.rm = TRUE)
}
sd_vec
years <- c(2024, 3021, 2000, 1800, 800, 5050, 600, 7156)
years[(years %% 4 == 0 & years %% 100 != 0) | (years %% 400 == 0)]
install.packages("lubridate")
library(lubridate)
# Define the start and end dates
start_date <- as.Date("2015-01-01")
end_date <- as.Date("2025-12-31")
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(from = start_date, to = end_date, by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (date in date_sequence) {
# Extract the year
year <- year(date)
# Extract the quarter
quarter <- quarter(date)
# Extract the ISO week number
iso_week <- isoweek(date)
# Store the results in a data frame
results[[as.character(date)]] <- data.frame(
Date = as.character(date),
Year = year,
Quarter = quarter,
ISO_Week = iso_week
)
}
library(lubridate)
# Define the start and end dates
start_date <- as.Date("2015-01-01")
end_date <- as.Date("2025-12-31")
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(from = start_date, to = end_date, by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (dt in date_sequence) {
year_val <- year(dt)
quarter_val <- quarter(dt)
iso_week_val <- isoweek(dt)
results[[as.character(dt)]] <- data.frame(
Date = as.character(dt),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
library(lubridate)
# Define the start and end dates
start_date <- as.Date("2015-01-01")
end_date <- as.Date("2025-12-31")
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(from = start_date, to = end_date, by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (date_ in date_sequence) {
# Extract the year
year <- year(date_)
# Extract the quarter
quarter <- quarter(date_)
# Extract the ISO week number
iso_week <- isoweek(date_)
# Store the results in a data frame
results[[as.character(date)]] <- data.frame(
Date = as.character(date),
Year = year,
Quarter = quarter,
ISO_Week = iso_week
)
}
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (date_ in date_sequence) {
# Extract the year
year <- year(date_)
# Extract the quarter
quarter <- quarter(date_)
# Extract the ISO week number
iso_week <- isoweek(date_)
# Store the results in a data frame
results[[as.character(date)]] <- data.frame(
Date = as.character(date),
Year = year,
Quarter = quarter,
ISO_Week = iso_week
)
}
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (date_ in date_sequence) {
# Extract the year
year_val <- year(date_)
# Extract the quarter
quarter_val <- quarter(date_)
# Extract the ISO week number
iso_week_val <- isoweek(date_)
# Store the results in a data frame
results[[as.character(date_)]] <- data.frame(
Date = as.character(date_),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
month(ymd("2023-06-10"), label = TRUE)
# Iterate through each date in the sequence
for (date_ in date_sequence) {
# Extract the year
year_val <- year(date_)
# Extract the quarter
quarter_val <- quarter(date_)
# Extract the ISO week number
iso_week_val <- isoweek(date_)
# Store the results in a data frame
results[[as.character(date_)]] <- data.frame(
Date = as.character(date_),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (x in date_sequence) {
# Extract the year
year_val <- year(x)
# Extract the quarter
quarter_val <- quarter(x)
# Extract the ISO week number
iso_week_val <- isoweek(x)
# Store the results in a data frame
results[[as.character(x)]] <- data.frame(
Date = as.characterx),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
# Combine the individual data frames into a single data frame
final_results <- do.call(rbind, results)
final_results
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (x in date_sequence) {
# Extract the year
year_val <- year(x)
# Extract the quarter
quarter_val <- quarter(x)
# Extract the ISO week number
iso_week_val <- isoweek(x)
# Store the results in a data frame
results[[as.Date(x)]] <- data.frame(
Date = as.characterx),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
# Combine the individual data frames into a single data frame
final_results <- do.call(rbind, results)
final_results
library(lubridate)
# Generate the sequence of dates, spaced by every two months
date_sequence <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
# Create an empty list to store the results
results <- list()
# Iterate through each date in the sequence
for (x in date_sequence) {
# Extract the year
year_val <- year(x)
# Extract the quarter
quarter_val <- quarter(x)
# Extract the ISO week number
iso_week_val <- isoweek(x)
# Store the results in a data frame
results[[as.character(x)]] <- data.frame(
Date = as.character(x),
Year = year_val,
Quarter = quarter_val,
ISO_Week = iso_week_val
)
}
library(lubridate)
date_seq <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
data.frame(
date = date_seq,
year = year(date_seq),
quarter = quarter(date_seq),
iso_week = isoweek(date_seq)
)
library(lubridate)
date_seq <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
output <- data.frame(
date = date_seq,
year = year(date_seq),
quarter = quarter(date_seq),
iso_week = isoweek(date_seq)
)
output
library(lubridate)
date_seq <- seq(ymd("2015-01-01"), ymd("2025-12-31"), by = "2 months")
output <- data.frame(
date = date_seq,
year = year(date_seq),
quarter = quarter(date_seq),
iso_week = isoweek(date_seq)
)
head(output)
View(output)
sample_dates <- c("2018-03-15", "2020-07-20", "2023-01-10", "2025-09-05")
# Convert to Date objects
sample_dates <- ymd(sample_dates)
# Calculate differences between consecutive dates
month_diffs <- interval(sample_dates[-length(sample_dates)], sample_dates[-1]) %/% months(1)
week_diffs  <- as.numeric(diff(sample_dates), units = "weeks")
# Combine into a tibble for clarity
diffs <- tibble(
From = sample_dates[-length(sample_dates)],
To = sample_dates[-1],
Months_Between = month_diffs,
Weeks_Between = round(week_diffs, 1)
)
diffs
sample_dates <- c("2018-03-15", "2020-07-20", "2023-01-10", "2025-09-05")
# Convert to Date objects
sample_dates <- ymd(sample_dates)
# Calculate differences between consecutive dates
month_diffs <- interval(sample_dates[-length(sample_dates)], sample_dates[-1]) %/% months(1)
week_diffs  <- as.numeric(diff(sample_dates), units = "weeks")
# Combine into a tibble for clarity
diffs <- tibble(
From = sample_dates[-length(sample_dates)],
To = sample_dates[-1],
Months_Between = month_diffs,
Weeks_Between = round(week_diffs, 1)
)
diffs
library(tibble)
sample_dates <- c("2018-03-15", "2020-07-20", "2023-01-10", "2025-09-05")
# Convert to Date objects
sample_dates <- ymd(sample_dates)
# Calculate differences between consecutive dates
month_diffs <- interval(sample_dates[-length(sample_dates)], sample_dates[-1]) %/% months(1)
week_diffs  <- as.numeric(diff(sample_dates), units = "weeks")
# Combine into a tibble for clarity
diffs <- tibble(
From = sample_dates[-length(sample_dates)],
To = sample_dates[-1],
Months_Between = month_diffs,
Weeks_Between = round(week_diffs, 1)
)
diffs
View(diffs)
library(tibble)
sample_dates <- c("2018-03-15", "2020-07-20", "2023-01-10", "2025-09-05")
# Convert to Date objects
sample_dates <- ymd(sample_dates)
# Calculate differences between consecutive dates
month_diffs <- interval(sample_dates[-length(sample_dates)], sample_dates[-1]) %/% months(1)
week_diffs  <- as.numeric(diff(sample_dates), units = "weeks")
# Combine into a tibble for clarity
diffs <- tibble(
From = sample_dates[-length(sample_dates)],
To = sample_dates[-1],
months_between = month_diffs,
weeks_between = round(week_diffs, 1)
)
diffs
num_lists <- list(c(4, 16, 25, 36, 49), c(2.3, 5.7, 8.1, 11.4), c(10, 20, 30, 40, 50))
map_dbl(num_lists, mean)
map_dbl(num_lists, median)
map_dbl(num_lists, sd)
library(purrr)
num_lists <- list(c(4, 16, 25, 36, 49), c(2.3, 5.7, 8.1, 11.4), c(10, 20, 30, 40, 50))
map_dbl(num_lists, mean)
map_dbl(num_lists, median)
map_dbl(num_lists, sd)
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# Use possibly() to safely attempt parsing each string
safe_parse <- possibly(
.f = ~ parse_date_time(.x, orders = c("ymd", "Ymd", "d-b-Y")),
otherwise = NA
)
# Apply safe parsing
parsed_dates <- map(date_strings, safe_parse)
# Extract month names (label = TRUE gives name instead of number)
month_names <- map(parsed_dates, ~ if (!is.na(.x)) month((.x, label = TRUE, abbr = FALSE) else NA)
# Show the results
month_names
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# Define a safe parser function using possibly()
safe_parse <- possibly(function(x) {
# Try multiple formats
if (!is.na(ymd(x))) return(ymd(x))
if (!is.na(mdy(x))) return(mdy(x))
if (!is.na(dmy(x))) return(dmy(x))
# Return NA if none work
return(NA_Date_)
}, otherwise = NA_Date_)
# Parse the dates
parsed_dates <- map(date_strings, safe_parse)
# Extract month names
month_names <- map_chr(parsed_dates, ~ if (!is.na(.x)) month(.x, label = TRUE, abbr = FALSE) else NA_character_)
# View result
month_names
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# List of dates in different formats, including one invalid date
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# Define a safe function to try parsing each date
safe_date <- possibly(function(x) {
# Tryiing different formats one by one
if (!is.na(ymd(x))) return(ymd(x))       # format: "2023-06-10"
if (!is.na(mdy(x))) return(mdy(x))       # format: "12/25/2022"
if (!is.na(dmy(x))) return(dmy(x))       # format: "15-Aug-2021"
return(NA)  # Return NA if nothing works
}, otherwise = NA)
# Apply the safe_date function to each item in the list
parsed_dates <- map(date_strings, safe_date)
# Extract the full month name (e.g., "June") from each valid date
month_names <- map_chr(parsed_dates, function(date) {
if (!is.na(date)) {
return(month(date, label = TRUE, abbr = FALSE))
} else {
return(NA_character_)  # If date is NA, return NA as a character
}
})
# Show the result
month_names
library(lubridate)
library(purrr)
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# List of dates in different formats, including one invalid date
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# Define a safe function to try parsing each date
safe_date <- possibly(function(x) {
# Tryiing different formats one by one
if (!is.na(ymd(x))) return(ymd(x))       # format: "2023-06-10"
if (!is.na(mdy(x))) return(mdy(x))       # format: "12/25/2022"
if (!is.na(dmy(x))) return(dmy(x))       # format: "15-Aug-2021"
return(NA)  # Return NA if nothing works
}, otherwise = NA)
# Apply the safe_date function to each item in the list
parsed_dates <- map(date_strings, safe_date)
# Extract the full month name (e.g., "June") from each valid date
month_names <- map_chr(parsed_dates, function(date) {
if (!is.na(date)) {
return(month(date, label = TRUE, abbr = FALSE))
} else {
return(NA_character_)  # If date is NA, return NA as a character
}
})
# Show the result
month_names
# List of mixed date strings
date_strings <- list("2023-06-10", "2022/12/25", "15-Aug-2021", "InvalidDate")
# Define a safer date parser
safe_parse_date <- possibly(function(x) {
# Try parsing formats one by one and return the first successful one
for (f in list(ymd, mdy, dmy)) {
parsed <- suppressWarnings(f(x))
if (!is.na(parsed)) return(parsed)
}
return(NA)  # Return NA if none work
}, otherwise = NA)
# Parse the dates
parsed_dates <- map(date_strings, safe_parse_date)
# Extract month names, using as.character() to avoid the purrr warning
month_names <- map_chr(parsed_dates, function(date) {
if (!is.na(date)) {
return(as.character(month(date, label = TRUE, abbr = FALSE)))
} else {
return(NA_character_)
}
})
# Show the result
month_names
R.Version()
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
